//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.16.1.0 (NJsonSchema v10.7.2.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

namespace Geta.Cloud {

    export class Client {
        private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
        private baseUrl: string;
        protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

        constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
            this.http = http ? http : window as any;
            this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
        }

        /**
         * Sign in with administrator credentials
         * @param request Sign in parameters
         */
        usersAdminSignIn(request: SignInRequest): Promise<TokenSetResponse> {
            let url_ = this.baseUrl + "/users/admin/sign-in";
            url_ = url_.replace(/[?&]$/, "");

            const content_ = JSON.stringify(request);

            let options_: RequestInit = {
                body: content_,
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    "Accept": "application/json"
                }
            };

            return this.http.fetch(url_, options_).then((_response: Response) => {
                return this.processUsersAdminSignIn(_response);
            });
        }

        protected processUsersAdminSignIn(response: Response): Promise<TokenSetResponse> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200: any = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as TokenSetResponse;
                    return result200;
                });
            } else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400: any = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as CustomValidationProblemDetails;
                    return throwException("Possible error codes: \n - InvalidUserNameOrPassword", status, _responseText, _headers, result400);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<TokenSetResponse>(null as any);
        }

        /**
         * Register Administrators and Tenant administrators
         */
        usersAdminSignUp(request: AdminSignUpRequest): Promise<void> {
            let url_ = this.baseUrl + "/users/admin/sign-up";
            url_ = url_.replace(/[?&]$/, "");

            const content_ = JSON.stringify(request);

            let options_: RequestInit = {
                body: content_,
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                }
            };

            return this.http.fetch(url_, options_).then((_response: Response) => {
                return this.processUsersAdminSignUp(_response);
            });
        }

        protected processUsersAdminSignUp(response: Response): Promise<void> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
            if (status === 200) {
                return response.text().then((_responseText) => {
                    return;
                });
            } else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400: any = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as CustomValidationProblemDetails;
                    return throwException("Possible error codes: \n - UserAlreadyRegistered", status, _responseText, _headers, result400);
                });
            } else if (status === 401) {
                return response.text().then((_responseText) => {
                    let result401: any = null;
                    result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                    return throwException("A server side error occurred.", status, _responseText, _headers, result401);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<void>(null as any);
        }

        /**
         * Generate authorization url
         * @param provider (optional) External provider name
         * @param customProviderName (optional) Custom provider name. Should be provided if provider is set to 'Custom'
         * @param state (optional) An opaque value the clients adds to the initial request. The authorization server includes this value when redirecting back to the client.
         */
        oauth2Authorize(provider: string | null | undefined, customProviderName: string | null | undefined, state: string | null | undefined, x_Tenant_Name: string): Promise<AuthorizationResponse> {
            let url_ = this.baseUrl + "/oauth2/authorize?";
            if (provider !== undefined && provider !== null)
                url_ += "provider=" + encodeURIComponent("" + provider) + "&";
            if (customProviderName !== undefined && customProviderName !== null)
                url_ += "customProviderName=" + encodeURIComponent("" + customProviderName) + "&";
            if (state !== undefined && state !== null)
                url_ += "state=" + encodeURIComponent("" + state) + "&";
            url_ = url_.replace(/[?&]$/, "");

            let options_: RequestInit = {
                method: "GET",
                headers: {
                    "X-Tenant-Name": x_Tenant_Name !== undefined && x_Tenant_Name !== null ? "" + x_Tenant_Name : "",
                    "Accept": "application/json"
                }
            };

            return this.http.fetch(url_, options_).then((_response: Response) => {
                return this.processOauth2Authorize(_response);
            });
        }

        protected processOauth2Authorize(response: Response): Promise<AuthorizationResponse> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200: any = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AuthorizationResponse;
                    return result200;
                });
            } else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400: any = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                    return throwException("A server side error occurred.", status, _responseText, _headers, result400);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<AuthorizationResponse>(null as any);
        }

        /**
         * Exchange code grant for tokens
         * @param request Grant code exchange parameters
         */
        oauth2Token(x_Tenant_Name: string, request: GrantCodeExchangeRequest): Promise<TokenSetResponse> {
            let url_ = this.baseUrl + "/oauth2/token";
            url_ = url_.replace(/[?&]$/, "");

            const content_ = JSON.stringify(request);

            let options_: RequestInit = {
                body: content_,
                method: "POST",
                headers: {
                    "X-Tenant-Name": x_Tenant_Name !== undefined && x_Tenant_Name !== null ? "" + x_Tenant_Name : "",
                    "Content-Type": "application/json",
                    "Accept": "application/json"
                }
            };

            return this.http.fetch(url_, options_).then((_response: Response) => {
                return this.processOauth2Token(_response);
            });
        }

        protected processOauth2Token(response: Response): Promise<TokenSetResponse> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200: any = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as TokenSetResponse;
                    return result200;
                });
            } else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400: any = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                    return throwException("A server side error occurred.", status, _responseText, _headers, result400);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<TokenSetResponse>(null as any);
        }

        /**
         * Exchange refresh token for a new token set
         * @param request Authorization parameters
         */
        oauth2TokenRefresh(x_Tenant_Name: string, request: RefreshTokenExchangeRequest): Promise<TokenSetResponse> {
            let url_ = this.baseUrl + "/oauth2/token/refresh";
            url_ = url_.replace(/[?&]$/, "");

            const content_ = JSON.stringify(request);

            let options_: RequestInit = {
                body: content_,
                method: "POST",
                headers: {
                    "X-Tenant-Name": x_Tenant_Name !== undefined && x_Tenant_Name !== null ? "" + x_Tenant_Name : "",
                    "Content-Type": "application/json",
                    "Accept": "application/json"
                }
            };

            return this.http.fetch(url_, options_).then((_response: Response) => {
                return this.processOauth2TokenRefresh(_response);
            });
        }

        protected processOauth2TokenRefresh(response: Response): Promise<TokenSetResponse> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200: any = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as TokenSetResponse;
                    return result200;
                });
            } else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400: any = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                    return throwException("A server side error occurred.", status, _responseText, _headers, result400);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<TokenSetResponse>(null as any);
        }

        /**
         * Exchange 3rd party tokens for GCC tokens
         * @param accept_Language (optional)
         */
        oauth2Exchange(accept_Language: string | undefined, x_Tenant_Name: string, request: { [key in keyof typeof ExternalClaimType]?: string; }): Promise<TokenSetResponse> {
            let url_ = this.baseUrl + "/oauth2/exchange";
            url_ = url_.replace(/[?&]$/, "");

            const content_ = JSON.stringify(request);

            let options_: RequestInit = {
                body: content_,
                method: "POST",
                headers: {
                    "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                    "X-Tenant-Name": x_Tenant_Name !== undefined && x_Tenant_Name !== null ? "" + x_Tenant_Name : "",
                    "Content-Type": "application/json",
                    "Accept": "application/json"
                }
            };

            return this.http.fetch(url_, options_).then((_response: Response) => {
                return this.processOauth2Exchange(_response);
            });
        }

        protected processOauth2Exchange(response: Response): Promise<TokenSetResponse> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200: any = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as TokenSetResponse;
                    return result200;
                });
            } else if (status === 401) {
                return response.text().then((_responseText) => {
                    let result401: any = null;
                    result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                    return throwException("A server side error occurred.", status, _responseText, _headers, result401);
                });
            } else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400: any = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                    return throwException("A server side error occurred.", status, _responseText, _headers, result400);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<TokenSetResponse>(null as any);
        }

        /**
         * Sign in with credentials
         * @param request Sign in parameters
         */
        usersSignIn(x_Tenant_Name: string, request: SignInRequest): Promise<TokenSetResponse> {
            let url_ = this.baseUrl + "/users/sign-in";
            url_ = url_.replace(/[?&]$/, "");

            const content_ = JSON.stringify(request);

            let options_: RequestInit = {
                body: content_,
                method: "POST",
                headers: {
                    "X-Tenant-Name": x_Tenant_Name !== undefined && x_Tenant_Name !== null ? "" + x_Tenant_Name : "",
                    "Content-Type": "application/json",
                    "Accept": "application/json"
                }
            };

            return this.http.fetch(url_, options_).then((_response: Response) => {
                return this.processUsersSignIn(_response);
            });
        }

        protected processUsersSignIn(response: Response): Promise<TokenSetResponse> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200: any = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as TokenSetResponse;
                    return result200;
                });
            } else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400: any = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as CustomValidationProblemDetails;
                    return throwException("Possible error codes: \n - PasswordResetRequired\n- AccountConfirmationRequired\n- InvalidUserNameOrPassword", status, _responseText, _headers, result400);
                });
            } else if (status === 401) {
                return response.text().then((_responseText) => {
                    let result401: any = null;
                    result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                    return throwException("A server side error occurred.", status, _responseText, _headers, result401);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<TokenSetResponse>(null as any);
        }

        /**
         * Confirm account registration
         */
        usersConfirmation(x_Tenant_Name: string, request: AccountConfirmationRequest): Promise<void> {
            let url_ = this.baseUrl + "/users/confirmation";
            url_ = url_.replace(/[?&]$/, "");

            const content_ = JSON.stringify(request);

            let options_: RequestInit = {
                body: content_,
                method: "POST",
                headers: {
                    "X-Tenant-Name": x_Tenant_Name !== undefined && x_Tenant_Name !== null ? "" + x_Tenant_Name : "",
                    "Content-Type": "application/json",
                }
            };

            return this.http.fetch(url_, options_).then((_response: Response) => {
                return this.processUsersConfirmation(_response);
            });
        }

        protected processUsersConfirmation(response: Response): Promise<void> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
            if (status === 200) {
                return response.text().then((_responseText) => {
                    return;
                });
            } else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400: any = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as CustomValidationProblemDetails;
                    return throwException("Possible error codes: \n - UserDisabled\n- AccountConfirmationNotRequired\n- InvalidVerificationCode\n- VerificationCodeExpired\n- UserAlreadyRegistered", status, _responseText, _headers, result400);
                });
            } else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404: any = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                    return throwException("A server side error occurred.", status, _responseText, _headers, result404);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<void>(null as any);
        }

        /**
         * Resend account confirmation code
         */
        usersConfirmationResend(x_Tenant_Name: string, request: ResendAccountConfirmationRequest): Promise<DeliveryInfoResponse> {
            let url_ = this.baseUrl + "/users/confirmation/resend";
            url_ = url_.replace(/[?&]$/, "");

            const content_ = JSON.stringify(request);

            let options_: RequestInit = {
                body: content_,
                method: "POST",
                headers: {
                    "X-Tenant-Name": x_Tenant_Name !== undefined && x_Tenant_Name !== null ? "" + x_Tenant_Name : "",
                    "Content-Type": "application/json",
                    "Accept": "application/json"
                }
            };

            return this.http.fetch(url_, options_).then((_response: Response) => {
                return this.processUsersConfirmationResend(_response);
            });
        }

        protected processUsersConfirmationResend(response: Response): Promise<DeliveryInfoResponse> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200: any = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as DeliveryInfoResponse;
                    return result200;
                });
            } else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400: any = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as CustomValidationProblemDetails;
                    return throwException("Possible error codes: \n - ConfirmationCodeDeliveryFailure\n- AccountConfirmationNotRequired\n- UserDisabled", status, _responseText, _headers, result400);
                });
            } else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404: any = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                    return throwException("A server side error occurred.", status, _responseText, _headers, result404);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<DeliveryInfoResponse>(null as any);
        }

        /**
         * Clears the Idp session (if configured)
         */
        usersSignOut(x_Tenant_Name: string): Promise<SignOutResponse> {
            let url_ = this.baseUrl + "/users/sign-out";
            url_ = url_.replace(/[?&]$/, "");

            let options_: RequestInit = {
                method: "POST",
                headers: {
                    "X-Tenant-Name": x_Tenant_Name !== undefined && x_Tenant_Name !== null ? "" + x_Tenant_Name : "",
                    "Accept": "application/json"
                }
            };

            return this.http.fetch(url_, options_).then((_response: Response) => {
                return this.processUsersSignOut(_response);
            });
        }

        protected processUsersSignOut(response: Response): Promise<SignOutResponse> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200: any = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as SignOutResponse;
                    return result200;
                });
            } else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400: any = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as CustomValidationProblemDetails;
                    return throwException("Possible error codes: \n - InvalidRequest", status, _responseText, _headers, result400);
                });
            } else if (status === 401) {
                return response.text().then((_responseText) => {
                    let result401: any = null;
                    result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                    return throwException("A server side error occurred.", status, _responseText, _headers, result401);
                });
            } else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404: any = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                    return throwException("A server side error occurred.", status, _responseText, _headers, result404);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<SignOutResponse>(null as any);
        }

        /**
         * Change password
         * @param accept_Language (optional)
         */
        usersChangePassword(accept_Language: string | undefined, x_Tenant_Name: string, request: ChangePasswordRequest): Promise<void> {
            let url_ = this.baseUrl + "/users/change-password";
            url_ = url_.replace(/[?&]$/, "");

            const content_ = JSON.stringify(request);

            let options_: RequestInit = {
                body: content_,
                method: "POST",
                headers: {
                    "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                    "X-Tenant-Name": x_Tenant_Name !== undefined && x_Tenant_Name !== null ? "" + x_Tenant_Name : "",
                    "Content-Type": "application/json",
                }
            };

            return this.http.fetch(url_, options_).then((_response: Response) => {
                return this.processUsersChangePassword(_response);
            });
        }

        protected processUsersChangePassword(response: Response): Promise<void> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
            if (status === 200) {
                return response.text().then((_responseText) => {
                    return;
                });
            } else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400: any = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as CustomValidationProblemDetails;
                    return throwException("Possible error codes: \n - UserNotFound\n- InvalidPassword\n- Required", status, _responseText, _headers, result400);
                });
            } else if (status === 401) {
                return response.text().then((_responseText) => {
                    let result401: any = null;
                    result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                    return throwException("A server side error occurred.", status, _responseText, _headers, result401);
                });
            } else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404: any = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                    return throwException("A server side error occurred.", status, _responseText, _headers, result404);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<void>(null as any);
        }

        /**
         * Request password reset
         * @param accept_Language (optional)
         */
        usersResetPassword(accept_Language: string | undefined, x_Tenant_Name: string, request: ResetPasswordRequest): Promise<DeliveryInfoResponse> {
            let url_ = this.baseUrl + "/users/reset-password";
            url_ = url_.replace(/[?&]$/, "");

            const content_ = JSON.stringify(request);

            let options_: RequestInit = {
                body: content_,
                method: "POST",
                headers: {
                    "Accept-Language": accept_Language !== undefined && accept_Language !== null ? "" + accept_Language : "",
                    "X-Tenant-Name": x_Tenant_Name !== undefined && x_Tenant_Name !== null ? "" + x_Tenant_Name : "",
                    "Content-Type": "application/json",
                    "Accept": "application/json"
                }
            };

            return this.http.fetch(url_, options_).then((_response: Response) => {
                return this.processUsersResetPassword(_response);
            });
        }

        protected processUsersResetPassword(response: Response): Promise<DeliveryInfoResponse> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
            if (status === 200) {
                return response.text().then((_responseText) => {
                    let result200: any = null;
                    result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as DeliveryInfoResponse;
                    return result200;
                });
            } else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400: any = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as CustomValidationProblemDetails;
                    return throwException("Possible error codes: \n - PasswordResetLimitExceeded\n- ConfirmationCodeDeliveryFailure\n- AccountConfirmationRequired\n- UserDisabled", status, _responseText, _headers, result400);
                });
            } else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404: any = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                    return throwException("A server side error occurred.", status, _responseText, _headers, result404);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<DeliveryInfoResponse>(null as any);
        }

        /**
         * Confirm password reset
         */
        usersResetPasswordConfirm(x_Tenant_Name: string, request: ConfirmPasswordResetRequest): Promise<void> {
            let url_ = this.baseUrl + "/users/reset-password/confirm";
            url_ = url_.replace(/[?&]$/, "");

            const content_ = JSON.stringify(request);

            let options_: RequestInit = {
                body: content_,
                method: "POST",
                headers: {
                    "X-Tenant-Name": x_Tenant_Name !== undefined && x_Tenant_Name !== null ? "" + x_Tenant_Name : "",
                    "Content-Type": "application/json",
                }
            };

            return this.http.fetch(url_, options_).then((_response: Response) => {
                return this.processUsersResetPasswordConfirm(_response);
            });
        }

        protected processUsersResetPasswordConfirm(response: Response): Promise<void> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
            if (status === 200) {
                return response.text().then((_responseText) => {
                    return;
                });
            } else if (status === 400) {
                return response.text().then((_responseText) => {
                    let result400: any = null;
                    result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as CustomValidationProblemDetails;
                    return throwException("Possible error codes: \n - VerificationCodeExpired\n- InvalidVerificationCode\n- AccountConfirmationRequired\n- UserDisabled", status, _responseText, _headers, result400);
                });
            } else if (status === 404) {
                return response.text().then((_responseText) => {
                    let result404: any = null;
                    result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProblemDetails;
                    return throwException("A server side error occurred.", status, _responseText, _headers, result404);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                    return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<void>(null as any);
        }
    }

    export interface TokenSetResponse {
        refreshToken?: string | undefined;
        idToken?: string | undefined;
        tokenType?: string | undefined;
        expiresOn?: number;
    }

    export interface ProblemDetails {
        type?: string | undefined;
        title?: string | undefined;
        status?: number | undefined;
        detail?: string | undefined;
        instance?: string | undefined;
    }

    export interface StatusCodeProblemDetails extends ProblemDetails {
    }

    export interface CustomValidationProblemDetails extends StatusCodeProblemDetails {
        errors?: { [key: string]: ProblemDetailItem[]; } | undefined;
    }

    export interface ProblemDetailItem {
        message?: string | undefined;
        code?: string | undefined;
    }

    export interface SignInRequest {
        userName?: string | undefined;
        password?: string | undefined;
    }

    export interface AdminSignUpRequest {
        /** User email address */
        email?: string | undefined;
        /** First name */
        firstName?: string | undefined;
        /** Last name */
        lastName?: string | undefined;
        /** Password */
        password?: string | undefined;
        /** Should be specified only when Administrator is creating Tenant Administrator, otherwise this value is ignored */
        tenant?: string | undefined;
    }

    export interface AuthorizationResponse {
        redirectUrl?: string | undefined;
    }

    export interface GrantCodeExchangeRequest {
        code?: string | undefined;
    }

    export interface RefreshTokenExchangeRequest {
        token?: string | undefined;
    }

    export enum ExternalClaimType {
        ExternalId = 1,
        FirstName = 2,
        LastName = 3,
        Email = 4,
        PhoneNumber = 5,
    }

    export interface AccountConfirmationRequest {
        userName?: string | undefined;
        code?: string | undefined;
    }

    export interface DeliveryInfoResponse {
        channel?: string | undefined;
        recipient?: string | undefined;
    }

    export interface ResendAccountConfirmationRequest {
        userName?: string | undefined;
    }

    export interface SignOutResponse {
        redirectUrl?: string | undefined;
    }

    export interface ChangePasswordRequest {
        oldPassword?: string | undefined;
        newPassword?: string | undefined;
    }

    export interface ResetPasswordRequest {
        userName?: string | undefined;
    }

    export interface ConfirmPasswordResetRequest {
        userName?: string | undefined;
        code?: string | undefined;
        password?: string | undefined;
    }

    export class ApiException extends Error {
        override message: string;
        status: number;
        response: string;
        headers: { [key: string]: any; };
        result: any;

        constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
            super();

            this.message = message;
            this.status = status;
            this.response = response;
            this.headers = headers;
            this.result = result;
        }

        protected isApiException = true;

        static isApiException(obj: any): obj is ApiException {
            return obj.isApiException === true;
        }
    }

    function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
        if (result !== null && result !== undefined)
            throw result;
        else
            throw new ApiException(message, status, response, headers, null);
    }

}